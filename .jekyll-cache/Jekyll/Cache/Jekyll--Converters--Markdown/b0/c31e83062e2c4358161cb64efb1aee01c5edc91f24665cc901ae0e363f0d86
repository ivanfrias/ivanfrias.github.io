I"$<h1 id="unary-challenge">Unary challenge</h1>

<h2 id="description-of-the-problem">Description of the problem</h2>

<p>This is the part of the algorithms series posts. Today we will review another interesting exercise called ‘Unary’.
Basically the idea is to parse a given string, convert each character to it’s ASCII representation and then convert it to the binary form.
After we have the binary form, we need to encode the binary string as follows:</p>

<ul>
  <li>if it’s a ‘1’, then we print the value ‘0’ one time</li>
  <li>if it’s a ‘0’, then we print the value ‘0’ two times</li>
</ul>

<p>If there is a block of digits with the same value then we print the encoding of that digit, concatenated with a space and with a count of how many occurences of that digit there is. e.g.:</p>

<p>Character ‘C’ to binary is ‘1000011’. The unary version of this is:
‘0 0 00 0000 0 00’. Block ‘0 0 ‘ represents one occurence of the 1 digit. Block ‘00 0000’ represents 4 occurences of the ‘0’ digit ( and so on and so forth).</p>

<h2 id="implementation">Implementation</h2>

<p>In a nutshell, to fix this we need to convert each character to binary, loop through the binary string, get hold of current character and next and based on whether they are equal or not, we decide to keep counting the number of occurences or not. The last step is to print out the number of digit occurences on the final string:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const unary = (input) =&gt; {
  let finalString = "";

  for (let i = 0; i &lt; input.length; i += 1) {
    const charCode = input.charCodeAt(i);
    const charCodeBinary = charCode.toString(2);
    let count = 0;

    for (let j = 0; j &lt; charCodeBinary.length; j += 1) {
      const current = charCodeBinary[j];
      const next =
        j + 1 &lt; charCodeBinary.length ? charCodeBinary[j + 1] : undefined;

      if (current === next) {
        count += 1;
      } else {
        count += 1;

        finalString += current === "0" ? "00 " : "0 ";

        for (let k = 1; k &lt;= count; k += 1) {
          finalString += "0";
        }

        finalString += " ";
        count = 0;
      }
    }
  }

  return finalString;
};
</code></pre></div></div>

<h2 id="line-by-line-analysis">Line by line analysis</h2>

<p>Loop through the input string:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (let i = 0; i &lt; input.length; i += 1)
</code></pre></div></div>

<p>Convert to ASCII and then to binary:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  const charCode = input.charCodeAt(i);
  const charCodeBinary = charCode.toString(2);
</code></pre></div></div>

<p>Loop through the generated binary string, assigning the current and next variables for comparison:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  for (let j = 0; j &lt; charCodeBinary.length; j += 1) {
    const current = charCodeBinary[j];
    const next =
      j + 1 &lt; charCodeBinary.length ? charCodeBinary[j + 1] : undefined;
</code></pre></div></div>

<p>If current digit and next digit are the same, we keep counting occurences:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  if (current === next) {
    count += 1;
  } else {
</code></pre></div></div>

<p>Otherwise, we print the block and reset the count:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  count += 1;

  finalString += current === "0" ? "00 " : "0 ";

  for (let k = 1; k &lt;= count; k += 1) {
    finalString += "0";
  }

  finalString += " ";
  count = 0;
</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>
<p>Hope you find this post interesting. I’ll keep exercises coming as they see fit. If you have any questions, please contact me via email <a href="frias.ivan@gmail.com">email</a>.</p>

:ET